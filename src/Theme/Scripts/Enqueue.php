<?php
declare( strict_types=1 );

namespace Lipe\Lib\Theme\Scripts;

use Lipe\Lib\Theme\Resources;

/**
 * Register and enqueue scripts and styles using the manifest file.
 *
 * @since    5.1.0
 *
 * @requires js-boilerplate:v9.2.0+
 * @requires postcss-boilerplate:v4.3.0+
 */
class Enqueue {
	public const BOILER_JS   = 'js';
	public const BOILER_PCSS = 'pcss';

	/**
	 * The file name of the resource without the path.
	 *
	 * @var string
	 */
	public readonly string $file_name;


	/**
	 * Instantiate the Enqueue class for this resource.
	 *
	 * @param ResourceHandles $handle - Current handle from within the boilerplate.
	 */
	final protected function __construct(
		protected readonly ResourceHandles $handle
	) {
		if ( ! SCRIPT_DEBUG && self::BOILER_PCSS === $this->handle->boilerplate() ) {
			$this->file_name = \str_replace( '.css', '.min.css', $this->handle->file() );
		} else {
			$this->file_name = $this->handle->file();
		}
	}


	/**
	 * Enqueue the current script or style with WP_Scripts.
	 *
	 * @param bool $in_footer - Load a JS script in the footer. Does not apply to CSS.
	 *
	 * @return void
	 */
	public function enqueue( bool $in_footer = true ): void {
		if ( \str_ends_with( $this->file_name, '.js' ) ) {
			wp_enqueue_script( $this->handle->handle(), $this->get_manifest()->get_url(), $this->handle->dependencies(), $this->get_version(), $in_footer );

			/**
			 * Add a `defer` or `async` attribute to the script tag.
			 */
			if ( $this->handle->is_defer() ) {
				wp_script_add_data( $this->handle->handle(), 'strategy', 'defer' );
			} elseif ( $this->handle->is_async() ) {
				wp_script_add_data( $this->handle->handle(), 'strategy', 'async' );
			}

			if ( ! SCRIPT_DEBUG ) {
				Resources::in()->integrity_javascript( $this->handle->handle(), $this->get_integrity() );
				/**
				 * Load the contents of the JS file inline.
				 */
				$registered = wp_scripts()->query( $this->handle->handle() );
				if ( $registered instanceof \_WP_Dependency && $this->handle->is_inline() ) {
					$registered->src = false;
					$registered->extra['data'] = file_get_contents( $this->get_file( true ) );
					return;
				}
			}
			return;
		}

		/**
		 * Webpack uses `style-loader` during development, so we only load a "JS" based CSS file if Webpack is not running.
		 */
		if ( self::BOILER_PCSS === $this->handle->boilerplate() || ! Util::in()->is_webpack_running( $this->handle ) ) {
			wp_enqueue_style( $this->handle->handle(), $this->get_manifest()->get_url(), $this->handle->dependencies(), $this->get_version() );
		}

		if ( ! SCRIPT_DEBUG && $this->handle->is_inline() ) {
			/**
			 * Allow WP Core to inline the stylesheet if under 20k.
			 *
			 * @see    wp_maybe_inline_styles
			 */
			wp_style_add_data( $this->handle->handle(), 'path', $this->get_file( true ) );
		}
	}


	/**
	 * Register the current script or style with WP_Scripts.
	 *
	 * Used when a resource should be registered but not enqueued.
	 *
	 * @return void
	 */
	public function register(): void {
		if ( \str_ends_with( $this->file_name, '.js' ) ) {
			wp_register_script( $this->handle->handle(), $this->get_manifest()->get_url(), $this->handle->dependencies(), $this->get_version(), true );
		} else {
			wp_register_style( $this->handle->handle(), $this->get_manifest()->get_url(), $this->handle->dependencies(), $this->get_version() );
		}
	}


	/**
	 * Return the path of the file relative to the theme.
	 *
	 * @param bool $full_path - Include a full path to the file.
	 *
	 * @return string
	 */
	public function get_file( bool $full_path = false ): string {
		if ( $full_path ) {
			return $this->handle->dist_path() . $this->file_name;
		}

		$path = \str_replace( trailingslashit( get_stylesheet_directory() ), '', $this->handle->dist_path() );
		return "{$path}{$this->file_name}";
	}


	/**
	 * Get a version of the resource from the `hash` in
	 * the manifest file.
	 *
	 * If the hash does not exist, fallback to the root
	 * .revision file.
	 *
	 * @return string
	 */
	public function get_version(): string {
		return $this->get_manifest()->get_version();
	}


	/**
	 * Get the integrity for script generated by the JS app.
	 *
	 * @return string
	 */
	public function get_integrity(): string {
		return $this->get_manifest()->get_integrity();
	}


	/**
	 * Get the manifest files generated by:
	 * - Webpack `dist`.
	 * - PostCSS `dist`.
	 *
	 * @todo In version 6, kill this method in favor of using the handle method.
	 *
	 * @internal
	 *
	 * @return Manifest
	 */
	public function get_manifest(): Manifest {
		if ( \method_exists( $this->handle,
			'get_manifest' ) ) {
			return $this->handle->get_manifest();
		}

		if ( self::BOILER_PCSS === $this->handle->boilerplate() ) {
			return new PCSS_Manifest( $this->handle );
		}
		return new JS_Manifest( $this->handle );
	}


	/**
	 * Instantiate the Enqueue class for this resource.
	 *
	 * @param ResourceHandles $handle - Current handle from within the boilerplate.
	 */
	public static function factory( ResourceHandles $handle ): static {
		return new static( $handle );
	}
}
